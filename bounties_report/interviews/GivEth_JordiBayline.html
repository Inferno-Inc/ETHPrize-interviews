<link rel="stylesheet" href="../styles/main.css">

<h2>Jordi Baylina</h2>


<p>
16/05/2018 - Robbie, Sina
</p><ol>

<li><strong>What is your background?</strong> <ol>

 <li>Experience: 35 years of programming; 3 years in blockchains.
 <li>Learning more everyday; exciting from a global perspective.  <ol>

  <li>This tech can change society over time. We'll see centralised power disappear, the world will become more trustless, people will take responsibility for themselves.
<li><strong>What type of apps do you build?</strong> <ol>

 <li>One of my first smart contracts was liquid democracy for the DAO.
 <li>Smart contracts for the white-hat group that originated from the DAO.
 <li>Wrote the Minime contract – maybe not the best time now because of gas costs, but it is an interesting smart contract.
 <li>Did the Status ICO.
 <li>Liquid pledging for Giveth.
 <li>Pushing DappNode
 <li>Audits – for MakerDao and Aragon.
 <li>777 standard.
 <li>Working a lot on an identity project.
<li><strong>Where do you think improvements can be made?</strong> <ol>

 <li>before we can really go mainstream:  <ol>

  <li>Scalability.
  <li>Security.   <ol>

   <li>Writing smart contracts is not secure.
  <li>Usability
<li><strong>What types of tools would make security better?</strong> <ol>

 <li>It's important to communicate to everyone that whatever you do will help, but will never give a warranty that there won't be an error.
 <li>I'm a bit skeptical of formal verification stuff, but I think it's important to keep pushing it forward.
 <li>Do more audits.
 <li>Write defensive code. Don't try to do crazy things.
 <li>For the first time, we're mixing two things that haven't been mixed together:  <ol>

  <li>The two:   <ol>

   <li>Critical code – contracts holds money.
   <li>Open-source – everyone can see how it works.
  <li>E.g. you don't have this in planes – critical program but not open-source.
  <li>E.g. in a website – it could be open-source but not critical.
  <li>So you realize you need to write perfect code, but that's not possible. Because code is written by humans.
 <li>It's important to improve:   <ol>

  <li>1) do not take risks.   <ol>

   <li>Try to isolate the critical part. E.g. if you're doing an ICO, don't hold the ETH in the contract, instead put it directly into the multisig.
   <li>Minimize the box, with its known security vectors.
  <li>2) on one side, you have a blockchain that by definition that is immutable. On the other side, immutable is not compatible with making mistakes.   <ol>

   <li>Humans make mistakes. We are building things on top of that immutable base that could have mistakes.
   <li>But we need to keep blockchains immutable, because if don't, we lose their power.
   <li>How do we solve this?    <ol>

    <li>Possible approach is having a second layer –– instead of ETH, we use an ETHToken. ETHToken has governance built in and can be modified. You build it in a more centralized manner, it can be changed; and then overtime, you soften the centralization rules, and make it decentralized (take away the authority, make it operated by a DAO, etc).     <ol>

     <li>E.g. having an escape hatch would be super helpful. If there is a hack, it could be sent to the EF or whitehat group. And then you can decide what to do. Better than it going directly to a hacker.
    <li>And then you can build the smart contract applications on this second layer.
    <li>Want to make decentralization linear; so you don't have to take the risks from the beginning.
    <li>All contracts in Giveth have escape hatches built in.
    <li><strong>STANDARD LIBRARY for using ETHToken in your contract, layer for security, escape hatches => Jordi thinks might be a bit too early since we're still figuring it out. Other teams working on this Zeppelin, Aragon.</strong>
 <li>Better compilers. Better testers. Better formal verification. All the tooling helps.
 <li>There are some errors that are not due to programming – they're conceptual, due to economics, etc.
<li><strong>Seems like security is as much an education problem, as tooling. Any ideas how we should approach this?</strong> <ol>

 <li>Documentation helps.
 <li>Realize that you will spend proportion of 40-to-1 on testing/auditing your contract vs writing.
 <li>Team audits  <ol>

  <li>Doing an audit within your team.
  <li>Once you've done your personal work on the smart contract, and you've done your own audit; then get together with your team, and start talking about your concerns, and you'll see that one idea leads to another, and you discover issues.
 <li>Audits  <ol>

  <li>Write some small bugs in the code, and see if the code reviewers find that bug.
  <li>Even if the auditor knows that there are bugs, they will be forced to go deeper into the code.
 <li>Bug bounties.  <ol>

  <li>I was skeptical of these at first. Why would people review this code?
  <li>But I have seen personally over the last year that big security holes have been discovered in bug bounties.
  <li>Bug bounties force you to write very good code.   <ol>

   <li>You need to choose the right names for variables, document it, it needs to be understandable.
 <li>Good resource: Consensys, on the history of all bugs. <a href="https://github.com/ConsenSys/smart-contract-best-practices">https://github.com/ConsenSys/smart-contract-best-practices</a>
 <li>This wiki could be complemented with these more generic ideas – around bug bounties, reference smart contracts etc.  <ol>

  <li>Maybe even write a book around it. An open-source book.
 <li>Smart contract developers could do an annual event – to categorize all the new bugs, new patterns – and consolidate them into the knowledge base.
<li><strong>What frustrations are you having building smart contracts?</strong> <ol>

 <li>Debugger  <ol>

  <li>The debugger is still hard –– you have to learn crazy tricks to be able to do it faster.
 <li>Return codes  <ol>

  <li>When a function reverts, you want to know why it reverted.
 <li>Code coverage  <ol>

  <li>Truffle has something, but it's specific to truffle.
  <li>I'd like these tools to be more generic.
 <li>Truffle that works for larger projects  <ol>

  <li>Across multiple repositories. You want the contract repo to be able to publish it's interface, and another repo can use that to interact with it, etc.
<li><strong>How do you launch these tools?</strong> <ol>

 <li>The Solidity developer contest could be a good moment to introduce these projects. Devcon.
 <li>Someone needs to present it to you. It's a matter of marketing. You need to push.</li> </ol>
