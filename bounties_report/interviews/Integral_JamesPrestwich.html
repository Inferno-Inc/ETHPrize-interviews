<link rel="stylesheet" href="../styles/main.css">

<h2>James Prestwich</h2>


<p>
2/13/2018 
</p><ol>

<li><strong>What type of apps do you build?</strong> <ol>

 <li>Simple contracts to manage cross-chain contracts
<li><strong>How do you test things which interact with the blockchain?</strong> <ol>

 <li>Wrote tests with James on Integral stuff
<li><strong>Where did you go to first learn about Ethereum?</strong> <ol>

 <li>Did all the Ethereum tutorials -- set up the token
 <li>Integral: written in Solidity with Truffle -- derivatives platform
<li><strong>Other tools you use daily?</strong> <ol>

 <li>Python ETH Library - ABI Parsing expects events to be in two different formats neither of which you expect - ecosystem standardizes on hex strings 
 <li>RLP is a hot mess - why use a non-standard serialization format for everything
 <li>Ensures nobody understands what's going on and things aren't readable - serialization format for everything ETH - includes transaction data
 <li>As a human - can't reason very well about those blobs or what those structures will have
 <li>Developing contracts on Bitcoin first - Solidity, Script, Snark tidbits, IVY (compiles to bitcoin script)
<li><strong>Frustrations?</strong> <ol>

 <li>Solidity is the wrong tool. Imperative language and everything on blockchain is declarative. Solidity should be declarative. 
 <li>IVY is best example of for blockchain language. On blockchain control logic is impossible: blockchain never decides how or when a function is called. No such thing as on-chain control logic: off-chain controls how humans can manipulate state.
 <li>All lies: completely wrong tool for blockchain. This is what causes render mistakes: trying to write on-chain what happens, but should be defining what can/can not happen (Bitcoin: whether you can or cannot spend a UTXO). 
 <li>Require statements example of Solidity becoming declarative language is not a good way to fix this and modifiers are an anti-pattern:  <ol>

  <li>Either happens as atomic single unit at will of human or it doesn't?
 <li>Configurable constraints on-chain: we should still define them as constraints -- no math happens on-chain (not actually adding 2+2 on chain). 
 <li>Weird that tests are control logic for your code. Control logic is whether human makes a transaction.   <ol>

  <li>Idea that we are writing things that add variables on-chain is wrong.
  <li>Reality of state, state root and blockheader is what causes a lot of the bugs 
 <li>IVY: really heavy modification to write on ETH -- more easy to write languages for the EVM. A declarative language for EVM. Tooling for Solidity only recently got workable.
 <li>Onchain systems should define constraints around what cser can / cannot do -- they are the control logic of the program.
 <li>Cross chain contracts for integral is what users can and cannot do at what time and on what chain (declarative programming again). 
 <li>Checks, Effect, Interactions to write code. We need more good programming to prevent race conditions, re-entrancy, double spend etc:    <ol>

  <li>Transactions happen atomically, cant have overlap in state changes
  <li>Can shoe horn ETH into this by using Require / IF Statements (??)
  <li>Avoid modifiers as a pattern
  <li>That's always the effect of the Solidity you're writing - puts more pressure on the client    <ol>

   <li>Makes testing more intuitive -- specified tests you're testing against
 <li>Very interesting miner attack on EtherDelta: they front-run; make tx throw; collect the fees.
 <li>The problem with Solidity isn't expressiveness; it is shared state. Other transactions can get ahead of you and modify state that you rely on.
<li><strong>Proof of Stake</strong> –– getting someone slashed decreases supply, increasing value of ETH. Does this mean every ETH holder is incentivized to getting stakers slashed? <ol>

 <li>In the Blockchain/cryptography in general, there is attack-defense asymmetry with defence being stronger. As soon as you move towards servers, attack-defence asymmetry leans towards the attacker.</li> </ol>
