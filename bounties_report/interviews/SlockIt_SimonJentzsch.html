<link rel="stylesheet" href="../styles/main.css">

<h2>Simon Jentzsch</h2>


<p>
04/20/2018 Parker, Andy
</p><ol>

<li><strong>What do you do/build?</strong> <ol>

 <li>CTO of SlockIt.  <ol>

  <li>Daily standups like any other startup, making sure all our tools work correctly
  <li>Part of day consists of update on new tools, libraries and their respective stability. Assessing trade-offs is difficult and time-consuming work.
 <li>Consulting work, experience with real customers  <ol>

  <li>Connecting IOT devices to the blockchain   <ol>

   <li>Energy Web foundation, smart meters
   <li>Smart contracts for data incoming from IOT
   <li>Determine what  type of hardware they should use
 <li>Building universal sharing network (USN) in-house.   <ol>

  <li>Connect IOT devices, access control, rental and sharing settings
  <li>Launched MVP on Testnet and inviting beta users. Planning on deploying to Mainnet.   <ol>

   <li>Public repo containing architecture and contracts
   <li>All smart contracts will be publicly available after security audit
  <li>Use Kovan since its compatible with most clients. Also on Rinkeby.
  <li>Using Parity for tests, but interoperability between clients is lacking badly.
 <li>Gives and recieves audit  <ol>

  <li>First, internal security audit
  <li>Then, number of experts from diff. Teams. List of people they work with.
<li><strong>Tools?</strong> <ol>

 <li>Start with Truffle - mainly for testing and setting up environment  <ol>

  <li>Doesn't produce/support typescript
 <li>Extended version we produced and use for  <ol>

  <li>Typesafe contracts based on solidity contracts
  <li>Throws errors on incorrect smart contract types 
 <li>Usually write tests with Travis CI, for all three browsers (GETH, TestRPC, Parity)
 <li>Use Remix for debugging  <ol>

  <li>Wish we had a more stable and easier to use debugger!!
 <li>Test RPC vs Ganache  <ol>

  <li>Many tiny differences (output syntax, JSON RPC error messages, etc.)  between clients makes testing very hard between clients
 <li>RPC Specs need to be tightened up so that we can communicate with them from whichever framework, write tests easily and actually understand the error messages that come back.
 <li>Not specific enough, too much room for divergence
 <li>Web3 library is trying to limit this
<li><strong>Frustrations</strong> <ol>

 <li>IDE integration  <ol>

  <li>There are tools and plugins for different IDES. Being able to use Solidity just like any other language would be really nice   <ol>

   <li>Do just the basic stuff right.
  <li>Checkers/linters exist but they're all over the place. Integrated into IDE, not via CLI, would be helpful.   <ol>

   <li>Package manager for existing libraries needed that could manage packages and bundle them in a secure way
   <li>Manage standards better
   <li>Not just syntax highlighting, but code-assist/completion and deep syntactical and structural understanding.
 <li>Web3 Libraries  <ol>

  <li>Latest updates broke all our tests, so reverted to fixed versions
<li><strong>IOT security challenges?</strong> <ol>

 <li>Use blockchain to enhance security by using smart contracts for access-control  <ol>

  <li>Devices are dumb, smart contracts grant access
  <li>Downside if how to get a stable connection which is secure and able to run on low hardware specs
  <li>Clients that are able to run on small IOT devices is a big challenge. 
 <li>We're developing light client IOT device, Incubed - not just light client but IoT client for microprocessors etc. Can do verification without even syncing with headers.  <ol>

  <li>Devices that need to sync just a few times a day, in unstable WIFI env.
  <li>Network of full clients running on servers. Incube randomly choose nodes out of the networks. Send JSON RPC request, answered with signed block hash/header.
  <li>If you send wrong block hash, then they lose their deposit.
 <li>How do you store a private key on IOT device?   <ol>

  <li>IOT device pvt keys generated from unique aspects of that specific hardware so that each device can easily generate its own key without transporting it anywhere
  <li>Paying for gas from each device is a big challenge.
 <li>Trying to integrate with uPort and others for app key management
<li><strong>Would do you wish you tools could do that they can't currently?</strong> <ol>

 <li>Scalability is long-hoped for and looked forward to ;)  <ol>

  <li>Mainnet as main authority,. For different devices, different chains.
  <li>Current work around could be  to use bridges (parity)
  <li>Micropayment, multiply party, state channel Solutions like Raiden up and coming, but not ready yet
 <li>Contracts that pay only for your devices from a certain account
 <li>They currently use libraries and packages to avoid security issues
<li><strong>Where do you learn about Ethereum and EThereum dev?</strong> <ol>

 <li>Having people around, trying new things, debugging existing ones. Most important is talking to and working with people who know more than you do - there is no substitute for that it seems.